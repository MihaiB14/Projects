Facultatea de Automatica si Calculatoare prin LSAC organizează in fiecare semestru un LAN Party la care participă toți studenții care vor sa își testeze abilitățile la un anumit joc. Se dorește realizarea unei soluții software(program executabil) ce poate automatiza acest proces.

Cerințe
-Se va crea o listă cu informațiile din fișierul d.in(lista se va forma prin adaugarea elementelor la inceput - O(1)).
-Se vor elimina din lista anterior creată, echipele cu cel mai mic punctaj de echipă (informațiile despre modul de calcul al acestui punctaj se găsesc în cadrul secțiunii Detalii Tehnice) astfel incat in lista sa ramana n echipe (unde n maxim si n este putere a lui 2).În cazul în care mai multe echipe au acelasi scor se elimina prima echipă gasita in lista. Dupa fiecare eliminare se va relua parcurgerea listei de la cap.
-Se vor implementa structurile de date necesare pentru a se efectua meciurile:
-Se va crea o coadă în care se vor pune meciurile dintre echipe.
-Echipele vor forma meciuri în ordinea în care se află în lista de la punctul anterior, primele două echipe vor forma primul meci (și așa mai departe).
-Se vor crea două stive - una pentru învinși și una pentru câștigători - ce vor conține echipele ce au pierdut, respectiv, au câștigat meciul anterior.
-Se vor introduce în stivă echipele în funcție de rezultatul obținut și se va adauga un punct la punctajul de echipă al echipelor ce au câștigat.
-In cazul unui meci in care ambele echipe au acelasi punctaj, se va alege prima echipa adaugata in meciul disputat.
-Se vor șterge echipele ce se găsesc în stiva de învinși.
-Din stiva de câștigători se vor extrage echipele și se va umple din nou coada de meciuri formându-se meciuri cu echipele consecutive (prima echipă scoasă din stivă va juca cu a doua echipa scoasă din stivă primul meci).
-Se vor repeta pașii enumerați pana la aflarea echipelor de pe primele 8 locuri, care vor fi salvate intr-o alta lista, dupa aflarea acestora se vor continua meciurile pana la aflarea echipei castigatoare.
-Se va realiza un clasament al ultimelor 8 echipe (salvate la subpunctul anterior) sub forma unui BST(Binary Search Tree). Acesta va fi ordonat după punctajul pe echipă și i se va afișa conținutul în ordine descrescătoare(in cazul in care doua echipe au acelasi punctaj se vor ordona in functie de nume, descrescator).
-Se va realiza un arbore de tip AVL cu ultimele 8 echipe (salvate la subpunctul 3, dar sortate ca la subpunctul 4) si se vor afisa echipele de pe nivelul 2 al arborelui.

Detalii Tehnice
-Rezultatele obținute în urma executări cerințelor din fișierul c.in vor fi scrise in fișierul r.out
-Pentru cerințele 1 si 2 este suficienta scrierea in fișierul de rezultate a numelor echipelor, in ordinea din lista creata, pe cate o linie separata.
-Pentru cerința 3 se va scrie in fișier la fiecare runda conținutul cozii de meciuri alături de conținutul stivei de învingători.
-Pentru cerința 4 se dorește afișarea BST -ului în ordine descrescătoare. Adică afișarea clasamentului în ordine descrescătoare.
-Pentru cerința 5 se dorește crearea unui AVL cu echipele de la sub punctul anterior și scrierea în fișier a echipelor de la nivelul 2.
-Structurile de date necesare trebuie deduse astfel încât sa respecte normele de buna implementare Ex: un jucator are nume, prenume, experienta - prin urmare se va folosi un tip de date care sa caracterizeze aceasta entitate:(Acelasi lucru trebuie facut si pentru alte tipuri de date necesare realizarii aplicatiei.)

Fisierele folosite de checker arata astfel:
c.in
1 0 0 0 0

Restricții
-Implementarea se va face folosind limbajul C++;
-Implementarea se va face folosind liste. Nu e permisa implementarea cu vector a stivelor, cozii și a listei cu echipe participante. Se recomanda folosirea pointerilor și eliberarea memoriei.;
-Se va evita pe cat posibil duplicarea nodurilor din lista.
-Nu se acceptă implementări cu tipuri de date cu memorie alocată static (se acceptă numai variabile locale de tip buffer pentru stocare temporară înainte de alocare);
-Se va depuncta lucrul nemodularizat (fără clase cu funcții membre). Operațiile pe structurile de date de tip arbore, coada, etc se fac folosind clase si funcții membre - Ex: adaugaNod, stergeNod, etc. Orice alte manipulări de date se fac, pe cat posibil, prin funcții specializate. ;
-Memoria trebuie eliberată.
-Menţineţi cel puţin un nivel minimal de aspect al codului şi evitaţi inconsistenţa (indentare haotică, numeroase combinaţii de caractere de tip „leading/trailing whitespace“, numirea variabilelor şi a funcţiilor în ordinea literelor din alfabet);
